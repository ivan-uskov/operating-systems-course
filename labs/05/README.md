# Лабораторная работа №5

- [Лабораторная работа №5](#лабораторная-работа-5)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание 1 — Потокобезопасное множество — 50 баллов](#задание-1--потокобезопасное-множество--50-баллов)
    - [Задание 2 — Исполнитель задач в фоновом потоке — 100 баллов](#задание-2--исполнитель-задач-в-фоновом-потоке--100-баллов)
      - [Примеры](#примеры)
      - [Подсказки](#подсказки)
    - [Задание 3 — Пул потоков — 150 баллов](#задание-3--пул-потоков--150-баллов)
    - [Задание 4 — Поисковая система — 300 баллов](#задание-4--поисковая-система--300-баллов)
      - [Поддерживаемые команды](#поддерживаемые-команды)
        - [Добавление файла в индекс](#добавление-файла-в-индекс)
        - [Добавление в индекс файлов из каталога](#добавление-в-индекс-файлов-из-каталога)
        - [Рекурсивное добавление в индекс файлов из каталога](#рекурсивное-добавление-в-индекс-файлов-из-каталога)
        - [Поиск документов, удовлетворяющих запросу](#поиск-документов-удовлетворяющих-запросу)
        - [Поиск документов, удовлетворяющих множеству запросов](#поиск-документов-удовлетворяющих-множеству-запросов)
        - [Удаление документа из индекса](#удаление-документа-из-индекса)
        - [Удаление каталога из индекса](#удаление-каталога-из-индекса)
      - [Требования](#требования-1)
        - [Оценка релевантности документа](#оценка-релевантности-документа)
  - [Ссылки](#ссылки)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее 120 баллов.
- Для получения оценки "хорошо" нужно набрать не менее 250 баллов.
- Для получения оценки "отлично" нужно набрать не менее 500 баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание 1 — Потокобезопасное множество — 50 баллов

Ознакомьтесь с классами `std::mutex` и `std::shared_mutex`, а также обёртками
`std::lock_guard`, `std::unique_lock` и `std::shared_lock`.

Напишите программу, которая строит `unordered_set<uint64_t>` из простых чисел
в диапазоне от 0 до введённого пользователем числа.
Ограничения этой задачи не позволяют использовать решето Эратосфена,
поэтому приходится искать простые числа перебором делителей от 2 до $\sqrt N$.

Чтобы ускорить решение задачи, распределите поиск делителей между несколькими потоками.
Распределите объем работы так, чтобы каждому из потоков досталось
примерно одинаковое количество чисел для проверки.
Подсказка: количество чисел будет неодинаковым. Объясните, почему так.

Чтобы избежать состояния гонки потоков, напишите шаблонный класс `ThreadsafeSet`
(потокобезопасное множество), предоставляющий потокобезопасные операции
для доступа к множеству.

```c++
template <typename T, typename H = std::hash<T>, typename Comp = std::equal_to<T>>
class ThreadsafeSet
{
public:
    // Разместите здесь операции, которые можно безопасно вызывать из нескольких потоков
private:
    std::unordered_set<T, H, Comp> m_set;
};
```

Ваша программа должна измерить время работы алгоритма в одном потоке (использующего `unordered_set`),
а также время работы многопоточного алгоритма, использующего `ThreadsafeSet`.

Программа должна выводить до 10 любых простых чисел, которые были найдены в однопоточном
и многопоточном варианте.

Постройте диаграмму, отображающую время работы алгоритма для верхней границы в 1 млн, 10 млн, 100 млн
при количестве потоков от 1 до 16.

Проанализируйте полученные результаты и сделайте выводы.

Используя [закон Амдала](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%90%D0%BC%D0%B4%D0%B0%D0%BB%D0%B0)
определите долю работы, которая не может быть распараллелена между потоками. 

### Задание 2 — Исполнитель задач в фоновом потоке — 100 баллов

Ознакомьтесь с классами `std::mutex` и `std::conditional_variable`.

Разработайте класс `BgThreadDispatcher`, который предоставляет возможность выполнять задачи в фоновом потоке.
Задачи представлены в виде `std::function<void()>`.
Задачи выполняются последовательно в порядке их поступления.

Исключение, выброшенное задачей, не должно препятствовать выполнению остальных задач.

Деструктор класса `BgThreadDispatcher` должен остановить фоновый поток и прекратить
выполнение задач в очереди.
Выполнение задач, которые не успели запуститься к моменту вызова деструктора, не гарантируется.

Для класса `BgThreadDispatcher` разработайте юнит-тесты.

Интерфейс класса представлен ниже:

```c++
class BgThreadDispatcher
{
public:
    using Task = std::function<void()>;

    // Копирование и присваивание объектов этого класса невозможно
    BgThreadDispatcher(const BgThreadDispatcher&) = delete;
    BgThreadDispatcher& operator=(const BgThreadDispatcher&) = delete;

    // Завершает работу фонового потока. 
    ~BgThreadDispatcher();

    // Отправляет задачу task на выполнение в фоновом потоке.
    // Фоновый поток последовательно выполняет задачи в порядке их поступления.
    // Вызов этого метода из фонового потока — неопределённое поведение.
    // Если BgThreadDispatcher остановлен, задача игнорируется.
    void Dispatch(Task task);

    // Блокирует работу текущего потока до окончания выполнения всех фоновых задач.
    // Вызов этого метода из фонового потока приводит к неопределённому поведению.
    // Если ранее был вызван метод Stop, то ожидание завершения не происходит.
    void Wait();

    // Сообщает фоновому потоку о необходимости остановить работу.
    // Задачи, которые не успели выполниться, игнорируются.
    void Stop();
};
```

#### Примеры

Эта программа выведет текст «1!»:

```c++
int main()
{
    using osync = std::osyncstream;
    BgThreadDispatcher dispatcher;
    dispatcher.Dispatch([]{ osync(std::cout) << "1"; }); // Выведет 1 в фоновом потоке
    dispatcher.Wait(); // Дождётся завершения фоновых задач 
    osync(std::cout) << "!"; // Выведет ! в основном потоке
}
```

Эта программа напечатает один из следующих текстов: «!123», «1!23» или «12!3»:

```c++
int main()
{
    using osync = std::osyncstream;
    BgThreadDispatcher dispatcher;
    dispatcher.Dispatch([]{ osync(std::cout) << "1"; }); // выведет 1 в фоновом потоке
    dispatcher.Dispatch([]{ osync(std::cout) << "2"; }); // Выведет 2 в фоновом потоке
    osync(std::cout) << "!"; // Выведет ! в основном потоке
    dispatcher.Wait(); // Дождётся печати 1 и 2
    dispatcher.Dispatch([]{ osync(std::cout) << "3"; }); // Выведет 3 в фоновом потоке
    dispatcher.Wait(); // Дождётся вывода 3
}
```

Эта программа напечатает один из следующих текстов: «!1», «1!» или «!»:

```c++
int main()
{
    using osync = std::osyncstream;
    BgThreadDispatcher dispatcher;
    dispatcher.Dispatch([]{ osync(std::cout) << "1"; }); // Выводим 1 в фоновом потоке
    osync(std::cout) << "!"; // Выводим ! в основном потоке
    // Вывод 1 не гарантируется, так как мы не вызвали Wait перед вызовом деструктора.
}
```

Следующая программа с большой вероятностью выведет «!1» или «1!». С очень низкой вероятностью выведет «!».

```c++
int main()
{
    using osync = std::osyncstream;
    BgThreadDispatcher dispatcher;
    dispatcher.Dispatch([]{ osync(std::cout) << "1"; }); // Выведет 1 в фоновом потоке
    osync(std::cout) << "!"; // Выведет ! в основном потоке
    // За 1 секунду фоновый поток успеет вывести 1
    std::this_thread:sleep_for(std::chrono::seconds(1));
}
```

Эта программа выведет «!»:

```c++
int main()
{
    BgThreadDispatcher dispatcher;
    dispatcher.Wait(); // Фоновых задач нет, метод сразу вернёт управление
    std::cout << "!";  // Выведет ! в главном потоке.
}
```

Эта программа с большой вероятностью выведет «1!» и с низкой «!»:

```c++
int main()
{
    BgThreadDispatcher dispatcher;
    dispatcher.Dispatch([]{ osync(std::cout) << "1"; }); // Выведет 1 в фоновом потоке
    // 1 секунды, скорее всего, хватит, чтобы успела вывестись 1.
    std::this_thread:sleep_for(std::chrono::seconds(1));
    dispatcher.Stop(); // Останавливаем выполнение фоновых задач
    dispatcher.Dispatch([]{ osync(std::cout) << "2"; }); // 2 выведена не будет, так как раньше был вызван Stop
    dispatcher.Wait(); // Дожидаемся завершения фоновых задач
    std::cout << "!";  // Выведет ! в главном потоке.
}
```

#### Подсказки

- Используйте `std::jthread` внутри `BgThreadDispatcher` для запуска фонового потока.
- Вам может понадобиться несколько экземпляров `std::conditional_variable`,
  чтобы организовать обмен информацией между потоками.
- Кроме `std::vector` есть и другие контейнеры.
- В юнит-тестах проверьте все описанные в примерах сценарии и при необходимости добавьте свои.
- Возможно, вы найдёте полезное применение классам `std::stop_token`, `std::stop_source`, `std::stop_callback` и `std::atomic<>`.
- Старайтесь не держать блокировку мьютекса дольше, чем необходимо.
  Что точно не стоит делать, так это вызывать `Task` с захваченным мьютексом.
- Ваш фреймворк для юнит-тестирования может иметь ограничения на работу с многопоточным кодом.
  Ознакомьтесь с инструкцией.
- Написание корректного многопоточного кода — сложная работа, требующая внимания и терпения. Не торопитесь.

### Задание 3 — Пул потоков — 150 баллов

Это задание — усовершенствованная версия предыдущей задачи. В нём нужно разработать класс `ThreadPool`,
который создаёт заданное количество рабочих потоков, которые параллельно извлекают задачи из очереди
и выполняют их.

```c++
class ThreadPool
{
public:
    using Task = std::function<void()>;

    // Создаёт пул из numThreads рабочих потоков
    explicit ThreadPool(unsigned numThreads);

    // Копирование и присваивание объектов этого класса невозможно
    ThreadPool(const ThreadPool&) = delete;
    ThreadPool& operator=(const ThreadPool&) = delete;

    // Завершает работу фонового потока. 
    ~ThreadPool();

    // Отправляет задачу task на выполнение в любом из фоновых потоков внутри пула.
    // Этот метод можно вызывать из любого потока, в том числе из любого потока внутри пула.
    // Если ThreadPool остановлен, задача игнорируется.
    void Dispatch(Task task);

    // Блокирует работу текущего потока до окончания выполнения всех фоновых задач.
    // Вызов этого метода из фонового потока приводит к неопределённому поведению.
    // Если ранее был вызван метод Stop, то ожидание завершения не происходит.
    void Wait();

    // Сообщает рабочим потокам о необходимости остановить работу
    // Задачи, которые не успели выполниться, игнорируются.
    void Stop();
};
```

Для тестирования класса `ThreadPool` разработайте юнит-тесты.

### Задание 4 — Поисковая система — 300 баллов

Разработайте приложение-поисковую систему для поиска текста внутри документов,
находящихся на диске. Поисковая система должна позволять индексировать текстовые файлы
для быстрого поиска. Индексация и поиск должны быть способны проходить
параллельно.

#### Поддерживаемые команды

После запуска программа должна входить в интерактивный режим и обрабатывать команды пользователя.

##### Добавление файла в индекс

```txt
add_file PATH
```

Индексирует файл с путём `PATH`. Повторная индексация одного и того же документа считается ошибкой.
При индексировании документа в памяти должна построиться структура данных,
позволяющая быстро находить документы, содержащий некоторый текст.

Каждый документ должен хранит следующую информацию

- id — 64-разрядное целое число, автоматически увеличивающееся для каждого документа.
- путь к файлу на диске
- информация о словах, которые в этом документе содержатся

##### Добавление в индекс файлов из каталога

```txt
add_dir PATH`
```

Индексирует все файлы внутри директории `PATH`.
Индексирование файлов должно выполняться в параллельных потоках.
Чтобы не создавать слишком много потоков, используйте `ThreadPool`
из предыдущего задания или его аналог из сторонних библиотек (например `boost::asio::thread_pool`).

##### Рекурсивное добавление в индекс файлов из каталога

```txt
add_dir_recursive PATH
```

Рекурсивно индексирует все файлы внутри директории `PATH`.
Индексирование файлов должно выполняться параллельно в пуле потоков.

##### Поиск документов, удовлетворяющих запросу

```txt
find QUERY
```

Ищет документы, удовлетворяющие запросу `QUERY` и выводит информацию о документах, которые лучше всего соответствуют запросу.
Документы выводятся в порядке убывания их релевантности, не более 10 штук.

Поиск происходит без учета регистра символов. То есть по запросу «cAt» должны находиться документы,
в которых есть различные варианты слова «cat»: «Cat», «cat», «CAT» и другие.

Например, следующая команда должна найти и вывести информацию обо всех документах,
содержащих слова `linux`, `kernel` и `mode`.

```txt
> find linux kernel mode
Search took 0.0031s:
1. id:25, relevance:3.75, path: /home/user/docs/Linux core for dummies.txt
2. id:7824, relevance:2.11113, path: /home/user/docs/linux-vs-windows.txt
3. id:328, relevance:0.00025, path: /home/user/docs/инструкция к стиральной машине.txt
---
```

В этом примере документ «Linux core for dummies.txt» лучше всего соответствует запросу,
а "инструкция к стиральной машине.txt» — меньше всего (например, если в ней случайно затесалось слово mode).

##### Поиск документов, удовлетворяющих множеству запросов

```txt
find_batch PATH
```

Параллельно выполняет поисковые запросы, записанные файле `PATH` по одному в каждой строке.
В результатах программа должна вывести порядковый номер запроса и результаты поиска.

В этом примере файл requests.txt содержит два запроса: «linux kernel mode» и «Harry Potter Hermione Granger»:

```txt
>find_batch /home/user/requests.txt
2. query: linux kernel mode
  Search took 0.013s:
  1. id:25, relevance:3.75, path: /home/user/docs/Linux core for dummies.txt
  2. id:7824, relevance:2.11113, path: /home/user/docs/linux-vs-windows.txt
  3. id:328, relevance:0.00025, path: /home/user/docs/инструкция к стиральной машине.txt
  ---
1. query: Harry Potter Hermione Granger
  Search took 0.025s:
  1. id:13, relevance 15.243, path: /home/user/books/Harry Potter and the Philosopher's Stone.txt
  2. id:76, relevance 13.889, path: /home/user/books/Harry Potter and the Deathly Hallows.txt
  3. id:772, relevance 12.772, path: /home/user/books/Harry Potter and Half Blood Prince.txt
  4. id:123, relevance 9.335, path: /home/user/books/Harry Potter and the Chamber of Secrets.txt
  5. id:70, relevance 7.9003, path: /home/user/books/Harry Potter and the Prisoner of Azkaban.txt
  6. id:34, relevance 6.13, path: /home/user/books/Harry Potter and the Goblet of Fire.txt
  7. id:14, relevance 5.87934, path: /home/user/books/Harry Potter and the Order of the Phoenix.txt
  8. id:1093, relevance 5.8814, path: /home/user/books/Harry Potter and the Methods of Rationality.txt
  ---
```

Из за параллельной работы не гарантируется их последовательное выполнение,
и второй запрос может быть обработан обработан и выведен раньше первого.

##### Удаление документа из индекса

```txt
remove_file PATH
```

Удаляет документ из индекса. Этот документ больше не может быть найден по ключевым словам.
Если документ с таким путём в индексе отсутствует, должно быть выведено сообщение об ошибке.

Сам документ должен остаться на диске.

##### Удаление каталога из индекса

```txt
remove_dir PATH
```

Удаляет из индекса все документы, находящиеся внутри каталога. Если какой-то из документов
присутствует на диске, но не в индексе, нужно проигнорировать эту ситуацию.
Документы должны удаляться из индекса параллельно.

```txt
remove_dir_recursive PATH
```

Эта команда выполняется аналогично `remove_dir`, только удаляет документы из индекса
рекурсивно.

#### Требования

Документы — обычные текстовые файлы, состоящие из одной или нескольких строк текста.
Словом считается последовательность из одного или нескольких символов английского алфавита.

Индексирование заключается в построении в памяти структуры данных для эффективной обработки
документов.
Например, ["Инвертированный индекс"](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B2%D0%B5%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81).

Используйте подходящие примитивы синхронизации, чтобы защитить структуры данных от состояния гонки.

##### Оценка релевантности документа

Для оценки релевантности документа запросу используйте меру [TF-IDF](https://ru.wikipedia.org/wiki/TF-IDF).
При иё использовании наибольшую релевантность получат документы, в которых используются
важные слова из запроса.

Допустим, есть набор документов:

|Документ|Текст|
|--------|-------|
| a.txt  | a cat is an animal|
| b.txt  | a dog is an animal too|
| c.txt  | a sparrow is a bird|

IDF (Inverse Document Frequency, обратная частота документа) термина равен логарифму
отношения числа документов к количеству документов, в которых этот термин встречается.

Рассчитаем TF-IDF для запроса «a cat».

|Документ|a           |cat              |
|--------|------------|-----------------|
|a.txt   |✅         |✅              |
|b.txt   |✅         |❌              |
|c.txt   |✅         |❌              |
|**IDF** |$log(3/3)=0$|$log(3/1)=1.0986$|

TF (Term Frequency, частота термина) равен частоте термина в каждом документе, где он встречается.
Для этого количество раз, которое термин встречается в документе делят на количество слов в документе.

|Документ|TF("a")      |TF("cat")|
|--------|-------------|---------|
|a.txt   |$1/5=0.2$    |$1/5=0.2$|
|b.txt   |$1/6=0.16667$|$0/6=0$  |
|c.txt   |$2/5=0.4$    |$0/5=0$  |

Величина TF-IDF равна произведению IDF термина на его TF в документе.
Для оценки релевантности вычисляют сумму TF-IDF по словам документа.

|Документ|TF-IDF("a")  |TF-IDF("cat")       |Релевантность      |
|--------|-------------|--------------------|-------------------|
|a.txt   |$0.2*0=0$    |$0.2*1.0986=0.01972$|$0+0.01972=0.01972$|
|b.txt   |$0.16667*0=0$|$0*1.0986=0$        |$0+0=0$            |
|c.txt   |$0.4*0=0$    |$0*1.0986=0$        |$0+0=0$            |

В итоге самым релевантным документом среди содержащих слова «a» и «cat»
будет a.txt. Так как слово "a" встречается абсолютно во всех документах,
оно не влияет на итоговую релевантность.

Допускается сдача работы, где релевантность вычисляется по более простым формулам,
например, используя частоту встречаемости слова в документе. В этом случае коэффициент
за баллы будет 0.8.

## Ссылки

- Класс [`std::mutex`](https://en.cppreference.com/w/cpp/thread/mutex)
- Класс [`std::shared_mutex`](https://en.cppreference.com/w/cpp/thread/shared_mutex)
- Класс [`std::unique_lock`](https://en.cppreference.com/w/cpp/thread/unique_lock)
- Класс [`std::shared_lock`](https://en.cppreference.com/w/cpp/thread/shared_lock)
- Класс [`std::lock_guard`](https://en.cppreference.com/w/cpp/thread/lock_guard)
- Класс [`std::conditional_variable`](https://en.cppreference.com/w/cpp/thread/condition_variable)
- Класс [`std::stop_callback`](https://en.cppreference.com/w/cpp/thread/stop_callback)
- Функция [`std::async`](https://en.cppreference.com/w/cpp/thread/async)
- Класс [`std::future`](https://en.cppreference.com/w/cpp/thread/future)
- Книга [C++ Concurrency in Action by Anthony Williams](https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition)
